// 맨 왼쪽 1부터 움직이면됨.
// 1001001001 => 0011001001 맨 오른쪽 1은 배제
// 1 => 2 => 3...
// 1사이에 0 있는 패턴이면 횟수 증가량++
// 01111001 => 4회
// 10111001 => 5회 여기서 i = 0의 1은 101패턴이니 k === 1 에서 *2를해서 2의 개수 보정치를 지님 즉 횟수 증가량이 += 2
// 횟수 증가량 기본 0임 101패턴 만나면 1씩 증가하거나 *2씩 될꺼임 근데 문제에서 모듈로 조건없으니 1씩 증가하는것일 확률이큼
// n - 1부터 0까지 순회하면서 0을 만나면 증가권 제거되고 횟수 증가량 증가. 다시 1만나면 증가권 복구
// 28분, 문제를 잘못 이해했었음 최소인줄
var maxOperations = function (s) {
  const n = s.length;
  let canUp = true;
  let k = 0;
  let result = 0;

  for (let i = n - 1; i >= 0; i--) {
    const char = s[i];

    if (canUp && char === "0") {
      canUp = false;
      k++;
    }

    if (char === "1") {
      canUp = true;
      result += k;
    }
  }

  return result;
};