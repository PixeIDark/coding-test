// 1. AND 연산자 (&)
// 두 비트가 모두 1일 때만 1
5 & 3; // 1
/*
  101 (5)
& 011 (3)
  001 (1)
*/

// 2. OR 연산자 (|)
// 두 비트 중 하나라도 1이면 1
5 | 3; // 7
/*
  101 (5)
| 011 (3)
  111 (7)
*/

// 3. XOR 연산자 (^)
// 두 비트가 다르면 1, 같으면 0
5 ^ 3; // 6
/*
  101 (5)
^ 011 (3)
  110 (6)
*/

// 4. NOT 연산자 (~)
// 비트를 전부 반전
~5; // -6
/*
  00000101 (5)
  11111010 (-6)
*/

// 5. 왼쪽 시프트 (<<)
// 비트를 왼쪽으로 이동, 오른쪽은 0으로 채움
5 << 1; // 10
/*
  00000101 (5)
  00001010 (10)
*/

// 6. 오른쪽 시프트 (>>)
// 비트를 오른쪽으로 이동, 왼쪽은 부호비트로 채움
5 >> 1; // 2
/*
  00000101 (5)
  00000010 (2)
*/

// 1. n번째 비트가 1인지 확인
if (x & (1 << n)) {
  // n번째 비트가 1
}

// 2. n번째 비트를 1로 설정
x |= 1 << n;

// 3. n번째 비트를 0으로 설정
x &= ~(1 << n);

// 4. n번째 비트를 토글(반전)
x ^= 1 << n;

// 5. 가장 오른쪽의 1을 제거
x &= x - 1;

// 6. 2의 거듭제곱인지 확인
if ((x & (x - 1)) === 0) {
  // 2의 거듭제곱
}

// 7. 가장 오른쪽의 1의 위치 찾기
const rightmostOne = x & -x;
