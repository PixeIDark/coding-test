// 라이언이 최대한의 점수차이로 우승 할 경우의 맞힌 배열 출력, 못이기면 [-1]
// a = b일 경우는 어피치가 k점을 가져갑니다.
// k점을 여러 발 맞혀도 k점 보다 많은 점수를 가져가는 게 아니고 k점만 가져가는 것을 유의하세요.
// 또한 a = b = 0 인 경우, 즉, 라이언과 어피치 모두 k점에 단 하나의 화살도 맞히지 못한 경우는 어느 누구도 k점을 가져가지 않습니다.

const p = 1,
  n = 5,
  info = [2, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0];
// Output: 	[0,2,2,0,1,0,0,0,0,0,0]

// 점수를 10점 부터 고려, 10점에 어피치의 화살이 0 이면 무조건 화살 하나 소모
// 어피치의 화살이 1 이상이면 그때부터 9점을 살펴봐야함.
// 뻇으면 *2의 차이 없는데 차지 한거면 *1의 효과 뺏기는 최소 2의 화살을 소모해야함.
// 화살 한개의 기대 값 고려해야함.
// dp에 출력 값 저장, 0번 인덱스가 10점
// 10점에 화살 하나 꼿는 것보다 9점에 화살 두개 꽃는게 이득.
// 백트래킹 해서 전으로 돌아가야함
function solution(n, info) {
  // 라이언과 어피치의 점수차를 계산하는 함수
  function calculateScore(apeach, ryan) {
    // 여기에 점수 계산 로직 구현
    // 라이언이 이기면 양수, 지면 음수, 비기면 0 반환
    let result = 0;

    for (let i = 0; i < ryan.length; i++) {
      if (apeach[i] === 0 && ryan[i] === 0) continue;
      const a = apeach[i] < ryan[i] ? 1 : -1;
      result += (10 - i) * a;
    }
    return result;
  }

  // 현재까지의 최대 점수차
  let maxDiff = 0;
  // 정답 배열 (최대 점수차를 만드는 라이언의 과녁 기록)
  let answer = Array(11).fill(0);

  // DFS 함수: 현재 인덱스, 남은 화살, 라이언의 과녁 상황을 매개변수로 받음
  function dfs(idx, arrowsLeft, ryan) {
    // 1. 종료 조건
    // - 화살을 다 쐈거나 (arrowsLeft === 0)
    // - 마지막 인덱스까지 도달했을 때 (idx > 10)
    if (arrowsLeft === 0 || idx > 10) return;

    // 2. 현재 인덱스의 과녁을 선택하는 경우
    // - 어피치보다 한발 더 쏘거나
    // 3. 현재 인덱스의 과녁을 선택하지 않는 경우
    // - 다음 인덱스로 넘어감
    // 4. 최대 점수차를 갱신하는 경우
    // - 현재까지의 최대 점수차보다 큰 경우
    // - 같은 점수차인데 낮은 점수를 더 많이 맞힌 경우
  }

  // DFS 시작: 초기 상태로 호출
  dfs(0, n, Array(11).fill(0));

  // 라이언이 이길 수 없는 경우 [-1] 반환
  return maxDiff <= 0 ? [-1] : answer;
}

console.log(solution(n, info));
